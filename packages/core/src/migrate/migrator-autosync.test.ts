import { types } from 'pg';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { Entity, Field, Id } from '../entity/index.js';
import { MariadbQuerierPool } from '../maria/mariadbQuerierPool.js';
import { MySql2QuerierPool } from '../mysql/mysql2QuerierPool.js';
import { PgQuerierPool } from '../postgres/pgQuerierPool.js';
import { Sqlite3QuerierPool } from '../sqlite/sqliteQuerierPool.js';
import type { QuerierPool, SchemaIntrospector, SqlQuerier } from '../type/index.js';
import { MariadbSchemaIntrospector, MysqlSchemaIntrospector } from './introspection/mysqlIntrospector.js';
import { PostgresSchemaIntrospector } from './introspection/postgresIntrospector.js';
import { SqliteSchemaIntrospector } from './introspection/sqliteIntrospector.js';
import { Migrator } from './migrator.js';

// Configure pg types for proper number parsing
types.setTypeParser(types.builtins.INT8, (value: string) => Number.parseInt(value, 10));

interface DatabaseConfig {
  name: string;
  pool: QuerierPool;
  createIntrospector: (pool: QuerierPool) => SchemaIntrospector;
  escapeId: (id: string) => string;
  createTableSql: (tableName: string, columns: string) => string;
  serialPrimaryKey: string;
  textType: string;
}

const databases: DatabaseConfig[] = [
  {
    name: 'PostgreSQL',
    pool: new PgQuerierPool({
      host: '0.0.0.0',
      port: 5442,
      user: 'test',
      password: 'test',
      database: 'test',
    }),
    createIntrospector: (pool) => new PostgresSchemaIntrospector(pool),
    escapeId: (id) => `"${id}"`,
    createTableSql: (tableName, columns) => `CREATE TABLE "${tableName}" (${columns})`,
    serialPrimaryKey: '"id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY',
    textType: 'TEXT',
  },
  {
    name: 'MySQL',
    pool: new MySql2QuerierPool({
      host: '0.0.0.0',
      port: 3316,
      user: 'test',
      password: 'test',
      database: 'test',
    }),
    createIntrospector: (pool) => new MysqlSchemaIntrospector(pool),
    escapeId: (id) => `\`${id}\``,
    createTableSql: (tableName, columns) => `CREATE TABLE \`${tableName}\` (${columns})`,
    serialPrimaryKey: '`id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY',
    textType: 'VARCHAR(255)',
  },
  {
    name: 'MariaDB',
    pool: new MariadbQuerierPool({
      host: '0.0.0.0',
      port: 3326,
      user: 'test',
      password: 'test',
      database: 'test',
      connectionLimit: 5,
      bigIntAsNumber: true,
    }),
    createIntrospector: (pool) => new MariadbSchemaIntrospector(pool),
    escapeId: (id) => `\`${id}\``,
    createTableSql: (tableName, columns) => `CREATE TABLE \`${tableName}\` (${columns})`,
    serialPrimaryKey: '`id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY',
    textType: 'VARCHAR(255)',
  },
  {
    name: 'SQLite',
    pool: new Sqlite3QuerierPool(':memory:'),
    createIntrospector: (pool) => new SqliteSchemaIntrospector(pool),
    escapeId: (id) => `\`${id}\``,
    createTableSql: (tableName, columns) => `CREATE TABLE \`${tableName}\` (${columns})`,
    serialPrimaryKey: '`id` INTEGER PRIMARY KEY AUTOINCREMENT',
    textType: 'TEXT',
  },
];

for (const db of databases) {
  describe(`Migrator autoSync Integration (${db.name})`, () => {
    let querier: SqlQuerier;
    let introspector: SchemaIntrospector;

    beforeAll(async () => {
      querier = (await db.pool.getQuerier()) as SqlQuerier;
      introspector = db.createIntrospector(db.pool);
    });

    afterAll(async () => {
      if (querier) {
        await querier.release();
      }
    });

    describe('adding new properties to existing entities', () => {
      const cleanupTable = async (tableName: string) => {
        try {
          await querier.run(`DROP TABLE IF EXISTS ${db.escapeId(tableName)}`);
        } catch {
          // Ignore errors
        }
      };

      it('should detect and sync a new property added to an existing entity', async () => {
        @Entity()
        class AutoSyncUserTest1 {
          @Id() id?: number;
          @Field() name?: string;
          @Field() email?: string;
        }

        const tableName = 'AutoSyncUserTest1';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}`),
        );

        let schema = await introspector.getTableSchema(tableName);
        expect(schema).toBeDefined();
        expect(schema.columns).toHaveLength(2);
        expect(schema.columns.map((c) => c.name).sort()).toEqual(['id', 'name']);

        const migrator = new Migrator(db.pool, { entities: [AutoSyncUserTest1] });
        await migrator.autoSync({ logging: true });

        schema = await introspector.getTableSchema(tableName);
        expect(schema).toBeDefined();
        expect(schema.columns).toHaveLength(3);
        expect(schema.columns.map((c) => c.name).sort()).toEqual(['email', 'id', 'name']);

        await cleanupTable(tableName);
      });

      it('should add multiple new properties to an existing entity', async () => {
        @Entity()
        class AutoSyncProductTest1 {
          @Id() id?: number;
          @Field() name?: string;
          @Field() price?: number;
          @Field() description?: string;
          @Field() active?: boolean;
        }

        const tableName = 'AutoSyncProductTest1';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncProductTest1] });
        await migrator.autoSync({ logging: true });

        const schema = await introspector.getTableSchema(tableName);
        expect(schema).toBeDefined();
        expect(schema.columns).toHaveLength(5);
        expect(schema.columns.map((c) => c.name).sort()).toEqual(['active', 'description', 'id', 'name', 'price']);

        await cleanupTable(tableName);
      });

      it('should not modify table when schema is already in sync', async () => {
        @Entity()
        class AutoSyncCategoryTest1 {
          @Id() id?: number;
          @Field() name?: string;
        }

        const tableName = 'AutoSyncCategoryTest1';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncCategoryTest1] });
        const schemaBefore = await introspector.getTableSchema(tableName);
        expect(schemaBefore).toBeDefined();

        await migrator.autoSync({ logging: true });

        const schemaAfter = await introspector.getTableSchema(tableName);
        expect(schemaAfter).toBeDefined();
        expect(schemaAfter.columns.length).toBe(schemaBefore.columns.length);

        await cleanupTable(tableName);
      });

      it('should create a new table if it does not exist', async () => {
        @Entity()
        class AutoSyncNewTableTest1 {
          @Id() id?: number;
          @Field() title?: string;
          @Field() content?: string;
        }

        const tableName = 'AutoSyncNewTableTest1';
        await cleanupTable(tableName);

        const migrator = new Migrator(db.pool, { entities: [AutoSyncNewTableTest1] });

        let exists = await introspector.tableExists(tableName);
        expect(exists).toBe(false);

        await migrator.autoSync({ logging: true });

        exists = await introspector.tableExists(tableName);
        expect(exists).toBe(true);

        const schema = await introspector.getTableSchema(tableName);
        expect(schema).toBeDefined();
        expect(schema.columns).toHaveLength(3);

        await cleanupTable(tableName);
      });

      it('should handle entity with custom table name', async () => {
        @Entity({ name: 'custom_user_table' })
        class AutoSyncCustomNameTest1 {
          @Id() id?: number;
          @Field() username?: string;
          @Field() email?: string;
        }

        const tableName = 'custom_user_table';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('username')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncCustomNameTest1] });
        await migrator.autoSync({ logging: true });

        const schema = await introspector.getTableSchema(tableName);
        expect(schema).toBeDefined();
        expect(schema.columns).toHaveLength(3);
        expect(schema.columns.map((c) => c.name).sort()).toEqual(['email', 'id', 'username']);

        await cleanupTable(tableName);
      });

      it('should handle field with custom column name', async () => {
        @Entity()
        class AutoSyncCustomColumnTest1 {
          @Id() id?: number;
          @Field({ name: 'user_email' }) email?: string;
        }

        const tableName = 'AutoSyncCustomColumnTest1';
        await cleanupTable(tableName);

        await querier.run(db.createTableSql(tableName, db.serialPrimaryKey));

        const migrator = new Migrator(db.pool, { entities: [AutoSyncCustomColumnTest1] });
        await migrator.autoSync({ logging: true });

        const schema = await introspector.getTableSchema(tableName);
        expect(schema).toBeDefined();
        expect(schema.columns.map((c) => c.name).sort()).toEqual(['id', 'user_email']);

        await cleanupTable(tableName);
      });
    });
  });
}
