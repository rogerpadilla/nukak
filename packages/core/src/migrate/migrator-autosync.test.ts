import { types } from 'pg';
import { afterAll, beforeAll, describe, expect, it, vi } from 'vitest';
import { Entity, Field, Id } from '../entity/index.js';
import { MariadbQuerierPool } from '../maria/mariadbQuerierPool.js';
import { MySql2QuerierPool } from '../mysql/mysql2QuerierPool.js';
import { PgQuerierPool } from '../postgres/pgQuerierPool.js';
import { Sqlite3QuerierPool } from '../sqlite/sqliteQuerierPool.js';
import type { QuerierPool, SchemaIntrospector, SqlQuerier } from '../type/index.js';
import { MariadbSchemaIntrospector, MysqlSchemaIntrospector } from './introspection/mysqlIntrospector.js';
import { PostgresSchemaIntrospector } from './introspection/postgresIntrospector.js';
import { SqliteSchemaIntrospector } from './introspection/sqliteIntrospector.js';
import { Migrator } from './migrator.js';

// Configure pg types for proper number parsing
types.setTypeParser(types.builtins.INT8, (value: string) => Number.parseInt(value, 10));

interface DatabaseConfig {
  name: string;
  pool: QuerierPool;
  createIntrospector: (pool: QuerierPool) => SchemaIntrospector;
  escapeId: (id: string) => string;
  createTableSql: (tableName: string, columns: string) => string;
  serialPrimaryKey: string;
  textType: string;
  unsafeAlterError?: string;
}

const databases: DatabaseConfig[] = [
  {
    name: 'PostgreSQL',
    pool: new PgQuerierPool({
      host: '0.0.0.0',
      port: 5442,
      user: 'test',
      password: 'test',
      database: 'test',
    }),
    createIntrospector: (pool) => new PostgresSchemaIntrospector(pool),
    escapeId: (id) => `"${id}"`,
    createTableSql: (tableName, columns) => `CREATE TABLE "${tableName}" (${columns})`,
    serialPrimaryKey: '"id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY',
    textType: 'TEXT',
  },
  {
    name: 'MySQL',
    pool: new MySql2QuerierPool({
      host: '0.0.0.0',
      port: 3316,
      user: 'test',
      password: 'test',
      database: 'test',
    }),
    createIntrospector: (pool) => new MysqlSchemaIntrospector(pool),
    escapeId: (id) => `\`${id}\``,
    createTableSql: (tableName, columns) => `CREATE TABLE \`${tableName}\` (${columns})`,
    serialPrimaryKey: '`id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY',
    textType: 'VARCHAR(255)',
  },
  {
    name: 'MariaDB',
    pool: new MariadbQuerierPool({
      host: '0.0.0.0',
      port: 3326,
      user: 'test',
      password: 'test',
      database: 'test',
      connectionLimit: 5,
      bigIntAsNumber: true,
    }),
    createIntrospector: (pool) => new MariadbSchemaIntrospector(pool),
    escapeId: (id) => `\`${id}\``,
    createTableSql: (tableName, columns) => `CREATE TABLE \`${tableName}\` (${columns})`,
    serialPrimaryKey: '`id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY',
    textType: 'VARCHAR(255)',
  },
  {
    name: 'SQLite',
    pool: new Sqlite3QuerierPool(':memory:'),
    createIntrospector: (pool) => new SqliteSchemaIntrospector(pool),
    escapeId: (id) => `\`${id}\``,
    createTableSql: (tableName, columns) => `CREATE TABLE \`${tableName}\` (${columns})`,
    serialPrimaryKey: '`id` INTEGER PRIMARY KEY AUTOINCREMENT',
    textType: 'TEXT',
    unsafeAlterError: 'Cannot alter column',
  },
];

for (const db of databases) {
  describe(`Migrator autoSync Integration (${db.name})`, () => {
    let querier: SqlQuerier;
    let introspector: SchemaIntrospector;

    beforeAll(async () => {
      querier = (await db.pool.getQuerier()) as SqlQuerier;
      introspector = db.createIntrospector(db.pool);
    });

    afterAll(async () => {
      if (querier) {
        await querier.release();
      }
    });

    describe('adding new properties to existing entities', () => {
      const cleanupTable = async (tableName: string) => {
        try {
          await querier.run(`DROP TABLE IF EXISTS ${db.escapeId(tableName)}`);
        } catch {
          // Ignore errors
        }
      };

      it('should detect and sync a new property added to an existing entity', async () => {
        @Entity()
        class AutoSyncUserTest1 {
          @Id() id?: number;
          @Field() name?: string;
          @Field() email?: string;
        }

        const tableName = 'AutoSyncUserTest1';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}`),
        );

        let ast = await introspector.introspect();
        let table = ast.getTable(tableName);
        expect(table).toBeDefined();
        expect(table.columns.size).toBe(2);
        expect(Array.from(table.columns.keys()).sort()).toEqual(['id', 'name']);

        const migrator = new Migrator(db.pool, { entities: [AutoSyncUserTest1] });
        await migrator.autoSync({ logging: true });

        ast = await introspector.introspect();
        table = ast.getTable(tableName);
        expect(table).toBeDefined();
        expect(table.columns.size).toBe(3);
        expect(Array.from(table.columns.keys()).sort()).toEqual(['email', 'id', 'name']);

        await cleanupTable(tableName);
      });

      it('should add multiple new properties to an existing entity', async () => {
        @Entity()
        class AutoSyncProductTest1 {
          @Id() id?: number;
          @Field() name?: string;
          @Field() price?: number;
          @Field() description?: string;
          @Field() active?: boolean;
        }

        const tableName = 'AutoSyncProductTest1';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncProductTest1] });
        await migrator.autoSync({ logging: true });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();
        expect(table.columns.size).toBe(5);
        expect(Array.from(table.columns.keys()).sort()).toEqual(['active', 'description', 'id', 'name', 'price']);

        await cleanupTable(tableName);
      });

      it('should not modify table when schema is already in sync', async () => {
        @Entity()
        class AutoSyncCategoryTest1 {
          @Id() id?: number;
          @Field() name?: string;
        }

        const tableName = 'AutoSyncCategoryTest1';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncCategoryTest1] });
        const astBefore = await introspector.introspect();
        const tableBefore = astBefore.getTable(tableName);
        expect(tableBefore).toBeDefined();

        await migrator.autoSync({ logging: true });

        const astAfter = await introspector.introspect();
        const tableAfter = astAfter.getTable(tableName);
        expect(tableAfter).toBeDefined();
        expect(tableAfter.columns.size).toBe(tableBefore.columns.size);

        await cleanupTable(tableName);
      });

      it('should create a new table if it does not exist', async () => {
        @Entity()
        class AutoSyncNewTableTest1 {
          @Id() id?: number;
          @Field() title?: string;
          @Field() content?: string;
        }

        const tableName = 'AutoSyncNewTableTest1';
        await cleanupTable(tableName);

        const migrator = new Migrator(db.pool, { entities: [AutoSyncNewTableTest1] });

        let exists = await introspector.tableExists(tableName);
        expect(exists).toBe(false);

        await migrator.autoSync({ logging: true });

        exists = await introspector.tableExists(tableName);
        expect(exists).toBe(true);

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();
        expect(table.columns.size).toBe(3);

        await cleanupTable(tableName);
      });

      it('should handle entity with custom table name', async () => {
        @Entity({ name: 'custom_user_table' })
        class AutoSyncCustomNameTest1 {
          @Id() id?: number;
          @Field() username?: string;
          @Field() email?: string;
        }

        const tableName = 'custom_user_table';
        await cleanupTable(tableName);

        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('username')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncCustomNameTest1] });
        await migrator.autoSync({ logging: true });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();
        expect(table.columns.size).toBe(3);
        expect(Array.from(table.columns.keys()).sort()).toEqual(['email', 'id', 'username']);

        await cleanupTable(tableName);
      });

      it('should handle field with custom column name', async () => {
        @Entity()
        class AutoSyncCustomColumnTest1 {
          @Id() id?: number;
          @Field({ name: 'user_email' }) email?: string;
        }

        const tableName = 'AutoSyncCustomColumnTest1';
        await cleanupTable(tableName);

        await querier.run(db.createTableSql(tableName, db.serialPrimaryKey));

        const migrator = new Migrator(db.pool, { entities: [AutoSyncCustomColumnTest1] });
        await migrator.autoSync({ logging: true });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();
        expect(Array.from(table.columns.keys()).sort()).toEqual(['id', 'user_email']);

        await cleanupTable(tableName);
      });

      it('should handle field rename safely (add new, keep old)', async () => {
        @Entity()
        class AutoSyncRenameTest {
          @Id() id?: number;
          @Field() newName?: string;
        }

        const tableName = 'AutoSyncRenameTest';
        await cleanupTable(tableName);

        // Create table with "oldName"
        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('oldName')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncRenameTest] });

        // Run autoSync (safe mode is default)
        await migrator.autoSync({ logging: true });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();
        // Should have 3 columns: id, oldName (kept), newName (added)
        expect(table.columns.size).toBe(3);
        expect(Array.from(table.columns.keys()).sort()).toEqual(['id', 'newName', 'oldName']);

        await cleanupTable(tableName);
      });

      it('should drop old column and add new one when renaming with safe: false', async () => {
        @Entity()
        class AutoSyncUnsafeRenameTest {
          @Id() id?: number;
          @Field() newName?: string;
        }

        const tableName = 'AutoSyncUnsafeRenameTest';
        await cleanupTable(tableName);

        // Create table with "oldName"
        await querier.run(
          db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('oldName')} ${db.textType}`),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncUnsafeRenameTest] });

        // Run autoSync with safe: false AND drop: true (explicit drop required)
        await migrator.autoSync({ logging: true, safe: false, drop: true });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();
        // Should have 2 columns: id, newName. oldName should be GONE.
        expect(table.columns.size).toBe(2);
        expect(Array.from(table.columns.keys()).sort()).toEqual(['id', 'newName']);

        // Verify data loss (implicit, since column is gone)

        await cleanupTable(tableName);
      });

      it('should NOT alter existing DOUBLE column to BIGINT for number field (Safe Mode)', async () => {
        @Entity()
        class AutoSyncFloatTest {
          @Id() id?: number;
          @Field() cost?: number;
        }

        const tableName = 'AutoSyncFloatTest';
        await cleanupTable(tableName);

        // Create table with "cost" as DOUBLE (valid for number)
        const doubleType = db.name === 'PostgreSQL' ? 'DOUBLE PRECISION' : 'DOUBLE';
        await querier.run(db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('cost')} ${doubleType}`));

        const migrator = new Migrator(db.pool, { entities: [AutoSyncFloatTest] });

        // Run autoSync (safe defaults to true)
        await migrator.autoSync({ logging: true });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();

        // The column type should REMAIN double/float, not change to bigint
        const costCol = table.columns.get('cost');
        expect(costCol).toBeDefined();

        // We normalize types to lowercase for check
        const type = costCol.type.category.toLowerCase();
        const isFloatCompatible =
          type.includes('double') || type.includes('float') || type.includes('real') || type.includes('decimal');

        expect(isFloatCompatible).toBe(true);
        expect(type).not.toContain('bigint');
        expect(type).not.toContain('int8'); // postgres bigint alias

        await cleanupTable(tableName);
      });

      it('should block drops even if safe: false (when drop: false)', async () => {
        @Entity()
        class AutoSyncNoDropTest {
          @Id() id?: number;
          @Field() name?: string;
        }

        const tableName = 'AutoSyncNoDropTest';
        await cleanupTable(tableName);

        // Create table with "extraColumn"
        await querier.run(
          db.createTableSql(
            tableName,
            `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}, ${db.escapeId('extraColumn')} ${db.textType}`,
          ),
        );

        const migrator = new Migrator(db.pool, { entities: [AutoSyncNoDropTest] });

        // Run autoSync with safe: false (but drop defaults to false)
        await migrator.autoSync({ logging: true, safe: false });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();
        // Should STILL have extraColumn because drop is false
        expect(table.columns.size).toBe(3);
        const colNames = Array.from(table.columns.keys()).sort();
        expect(colNames).toContain('extraColumn');

        await cleanupTable(tableName);
      });

      it('should log skipped migrations when safe mode blocks changes', async () => {
        @Entity()
        class AutoSyncLogTest {
          @Id() id?: number;
          @Field() name?: string;
        }

        const tableName = 'AutoSyncLogTest';
        await cleanupTable(tableName);

        // Create table with "extraColumn"
        await querier.run(
          db.createTableSql(
            tableName,
            `${db.serialPrimaryKey}, ${db.escapeId('name')} ${db.textType}, ${db.escapeId('extraColumn')} ${db.textType}`,
          ),
        );

        const migrator = new Migrator(db.pool, {
          entities: [AutoSyncLogTest],
          logger: true,
        });

        const consoleSpy = vi.spyOn(console, 'info').mockImplementation(() => {});

        // Run autoSync with safe: true (default) and logging: true
        await migrator.autoSync({ logging: true });

        expect(consoleSpy).toHaveBeenCalled();
        expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('skipped migration:'));
        expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Skipped dropping 1 columns'));

        consoleSpy.mockRestore();
        await cleanupTable(tableName);
      });

      it.skipIf(!!db.unsafeAlterError)('should alter column type when safe: false', async () => {
        @Entity()
        class AutoSyncUnsafeAlterTest {
          @Id() id?: number;
          @Field() cost?: number; // Defaults to bigint
        }

        const tableName = 'AutoSyncUnsafeAlterTest';
        await cleanupTable(tableName);

        // Create table with "cost" as DOUBLE
        const doubleType = db.name === 'PostgreSQL' ? 'DOUBLE PRECISION' : 'DOUBLE';
        await querier.run(db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('cost')} ${doubleType}`));

        const migrator = new Migrator(db.pool, { entities: [AutoSyncUnsafeAlterTest] });

        // Run autoSync with safe: false
        await migrator.autoSync({ logging: true, safe: false });

        const ast = await introspector.introspect();
        const table = ast.getTable(tableName);
        expect(table).toBeDefined();

        const costCol = table.columns.get('cost');
        expect(costCol).toBeDefined();
        // Should be converted to bigint (default for number)
        const type = costCol.type.category.toLowerCase();

        expect(type).toContain('int');
        expect(type).not.toContain('double');

        await cleanupTable(tableName);
      });

      it.runIf(!!db.unsafeAlterError)('should throw error when altering column type (system limitation)', async () => {
        @Entity()
        class AutoSyncUnsafeAlterErrorTest {
          @Id() id?: number;
          @Field() cost?: number;
        }

        const tableName = 'AutoSyncUnsafeAlterErrorTest';
        await cleanupTable(tableName);

        const doubleType = db.name === 'PostgreSQL' ? 'DOUBLE PRECISION' : 'DOUBLE';
        await querier.run(db.createTableSql(tableName, `${db.serialPrimaryKey}, ${db.escapeId('cost')} ${doubleType}`));

        const migrator = new Migrator(db.pool, { entities: [AutoSyncUnsafeAlterErrorTest] });

        // Run autoSync with safe: false - Expect Error
        await expect(migrator.autoSync({ logging: true, safe: false })).rejects.toThrow(db.unsafeAlterError);

        await cleanupTable(tableName);
      });
    });
  });
}
