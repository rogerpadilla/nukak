import { describe, expect, it } from 'vitest';
import { Entity, Field, Id, ManyToOne } from '../entity/index.js';
import { SqlSchemaGenerator } from './schemaGenerator.js';

// Test entities
@Entity()
class TestUser {
  @Id()
  id?: number;

  @Field({ length: 100 })
  name?: string;

  @Field({ unique: true })
  email?: string;

  @Field({ nullable: false })
  password?: string;

  @Field({ onInsert: Date.now })
  createdAt?: number;
}

@Entity({ name: 'blog_posts' })
class TestPost {
  @Id({ onInsert: () => crypto.randomUUID(), length: 36 })
  id?: string;

  @Field()
  title?: string;

  @Field({ columnType: 'text' })
  content?: string;

  @Field({ type: 'jsonb' })
  metadata?: Record<string, unknown>;

  @Field({ references: () => TestUser })
  authorId?: number;

  @ManyToOne()
  author?: TestUser;
}

describe('SqlSchemaGenerator (Postgres)', () => {
  const generator = new SqlSchemaGenerator('postgres');

  it('should generate CREATE TABLE for simple entity', () => {
    const sql = generator.generateCreateTable(TestUser);

    expect(sql).toContain('CREATE TABLE "TestUser"');
    expect(sql).toContain('"id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
    expect(sql).toContain('"name" VARCHAR(100)');
    expect(sql).toContain('"email" TEXT UNIQUE');
    expect(sql).toContain('"password" TEXT NOT NULL');
    expect(sql).toContain('"createdAt"');
  });

  it('should generate CREATE TABLE with UUID primary key', () => {
    const sql = generator.generateCreateTable(TestPost);

    expect(sql).toContain('CREATE TABLE "blog_posts"');
    expect(sql).toContain('"id" VARCHAR(36) PRIMARY KEY');
    expect(sql).toContain('"title" TEXT');
    expect(sql).toContain('"content" TEXT');
    expect(sql).toContain('"metadata" JSONB');
    expect(sql).toContain('"authorId" BIGINT');
  });

  it('should generate DROP TABLE statement', () => {
    const sql = generator.generateDropTable(TestUser);

    expect(sql).toBe('DROP TABLE IF EXISTS "TestUser";');
  });

  it('should generate CREATE INDEX statement', () => {
    const sql = generator.generateCreateIndex('users', {
      name: 'idx_users_email',
      columns: ['email'],
      unique: true,
    });

    expect(sql).toBe('CREATE UNIQUE INDEX IF NOT EXISTS "idx_users_email" ON "users" ("email");');
  });

  it('should generate CREATE TABLE with IF NOT EXISTS', () => {
    const sql = generator.generateCreateTable(TestUser, { ifNotExists: true });
    expect(sql).toContain('CREATE TABLE IF NOT EXISTS "TestUser"');
  });

  it('should handle already-typed column schemas', () => {
    const sql = generator.generateAlterTable({
      tableName: 'users',
      type: 'alter',
      columnsToAdd: [
        {
          name: 'profile_data',
          type: 'JSONB',
          nullable: true,
          isPrimaryKey: false,
          isAutoIncrement: false,
          isUnique: false,
        },
      ],
    });
    // Should NOT be JSONB(JSONB)
    expect(sql[0]).toContain('ADD COLUMN "profile_data" JSONB');
    expect(sql[0]).not.toContain('JSONB(');
  });

  it('should generate ALTER TABLE DOWN statements for column additions', () => {
    const sql = generator.generateAlterTableDown({
      tableName: 'users',
      type: 'alter',
      columnsToAdd: [
        {
          name: 'profile_data',
          type: 'JSONB',
          nullable: true,
          isPrimaryKey: false,
          isAutoIncrement: false,
          isUnique: false,
        },
      ],
    });
    expect(sql[0]).toBe('ALTER TABLE "users" DROP COLUMN "profile_data";');
  });

  it('should generate ALTER TABLE DOWN statements for column alterations', () => {
    const sql = generator.generateAlterTableDown({
      tableName: 'users',
      type: 'alter',
      columnsToAlter: [
        {
          from: {
            name: 'age',
            type: 'INTEGER',
            nullable: true,
            isPrimaryKey: false,
            isAutoIncrement: false,
            isUnique: false,
          },
          to: {
            name: 'age',
            type: 'BIGINT',
            nullable: false,
            isPrimaryKey: false,
            isAutoIncrement: false,
            isUnique: false,
          },
        },
      ],
    });
    expect(sql.length).toBeGreaterThan(0);
    expect(sql[0]).toContain('ALTER TABLE');
    expect(sql[0]).toContain('"age"');
    expect(sql[0]).toContain('INTEGER');
  });

  it('should generate ALTER TABLE DOWN statements for index additions', () => {
    const sql = generator.generateAlterTableDown({
      tableName: 'users',
      type: 'alter',
      indexesToAdd: [{ name: 'idx_users_email', columns: ['email'], unique: true }],
    });
    expect(sql[0]).toBe('DROP INDEX IF EXISTS "idx_users_email";');
  });

  it('should add TODO comment for dropped columns/indexes', () => {
    const sql1 = generator.generateAlterTableDown({
      tableName: 'users',
      type: 'alter',
      columnsToDrop: ['old_column'],
    });
    expect(sql1[0]).toContain('TODO');

    const sql2 = generator.generateAlterTableDown({
      tableName: 'users',
      type: 'alter',
      indexesToDrop: ['idx_old'],
    });
    expect(sql2[0]).toContain('TODO');
  });
});

describe('SqlSchemaGenerator (MySQL)', () => {
  const generator = new SqlSchemaGenerator('mysql');

  it('should generate CREATE TABLE for simple entity', () => {
    const sql = generator.generateCreateTable(TestUser);

    expect(sql).toContain('CREATE TABLE `TestUser`');
    expect(sql).toContain('`id` BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY');
    expect(sql).toContain('`name` VARCHAR(100)');
    expect(sql).toContain('`email` VARCHAR(255) UNIQUE');
    expect(sql).toContain('ENGINE=InnoDB');
  });

  it('should generate boolean as TINYINT(1)', () => {
    const boolType = generator.getSqlType({ type: Boolean }, Boolean);
    expect(boolType).toBe('TINYINT(1)');
  });

  it('should generate DROP INDEX with ON table', () => {
    const sql = generator.generateDropIndex('users', 'idx_email');
    expect(sql).toBe('DROP INDEX `idx_email` ON `users`;');
  });
});

describe('SqlSchemaGenerator (SQLite)', () => {
  const generator = new SqlSchemaGenerator('sqlite');

  it('should generate CREATE TABLE for simple entity', () => {
    const sql = generator.generateCreateTable(TestUser);

    expect(sql).toContain('CREATE TABLE `TestUser`');
    expect(sql).toContain('`id` INTEGER PRIMARY KEY AUTOINCREMENT');
    expect(sql).toContain('`name` TEXT');
    expect(sql).toContain('`email` TEXT UNIQUE');
  });

  it('should use TEXT for most types (SQLite dynamic typing)', () => {
    expect(generator.getSqlType({ columnType: 'varchar' }, String)).toBe('TEXT');
    expect(generator.getSqlType({ columnType: 'json' }, undefined)).toBe('TEXT');
    expect(generator.getSqlType({ columnType: 'uuid' }, undefined)).toBe('TEXT');
  });

  it('should use INTEGER for numeric types', () => {
    expect(generator.getSqlType({ columnType: 'int' }, undefined)).toBe('INTEGER');
    expect(generator.getSqlType({ columnType: 'bigint' }, undefined)).toBe('INTEGER');
    expect(generator.getSqlType({ type: Boolean }, Boolean)).toBe('INTEGER');
  });
});

describe('SqlSchemaGenerator Integration', () => {
  const generator = new SqlSchemaGenerator('postgres');

  it('should generate CREATE TABLE from TableNode', () => {
    const table: any = {
      name: 'users',
      columns: new Map([
        [
          'id',
          {
            name: 'id',
            type: { category: 'integer', size: 'big' },
            isPrimaryKey: true,
            isAutoIncrement: true,
            nullable: false,
            table: null,
          },
        ],
        ['name', { name: 'name', type: { category: 'string', length: 100 }, nullable: true, table: null }],
      ]),
      primaryKey: [],
      indexes: [],
      incomingRelations: [],
      outgoingRelations: [],
    };
    table.columns.get('id').table = table;
    table.columns.get('name').table = table;
    table.primaryKey = [table.columns.get('id')];

    const sql = generator.generateCreateTableFromNode(table);
    expect(sql).toContain('CREATE TABLE "users"');
    expect(sql).toContain('"id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY');
    expect(sql).toContain('"name" VARCHAR(100)');
  });

  it('should generate CREATE INDEX from IndexNode', () => {
    const table: any = { name: 'users' };
    const index: any = {
      name: 'idx_name',
      table,
      columns: [{ name: 'name' }],
      unique: true,
    };
    const sql = generator.generateCreateIndexFromNode(index);
    expect(sql).toBe('CREATE UNIQUE INDEX "idx_name" ON "users" ("name");');
  });

  it('should generate DROP TABLE from TableNode', () => {
    const table: any = { name: 'users' };
    const sql = generator.generateDropTableFromNode(table, { ifExists: true });
    expect(sql).toBe('DROP TABLE IF EXISTS "users";');
  });
});
